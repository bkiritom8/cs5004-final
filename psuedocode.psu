// GameObject Interface - Base interface for game objects
interface GameObject:
   function getName(): String
   function getDescription(): String

// AbstractGameObject - Base abstract class for game objects
abstract class AbstractGameObject implements GameObject:
   properties:
       name: String
       description: String

   constructor(name, description):
       this.name = name
       this.description = description

   function getName(): return name
   function getDescription(): return description

// Command Interface - For implementing command pattern
interface Command:
   function execute(gameWorld: GameWorld, player: Player): Boolean

// GameWorldLoader Interface - For loading game data
interface GameWorldLoader:
   function loadGameWorld(filename: String): GameWorld throws IOException

// Entity Interface - For objects that can have state changes
interface Entity extends GameObject:
   function isActive(): Boolean
   function setActive(active: Boolean): void

// GameEngineApp - Entry point class
class GameEngineApp:
   properties:
       gameFileName: String
       input: ReadableSource
       output: WriteableDestination

   constructor(gameFileName, input, output):
       this.gameFileName = gameFileName
       this.input = input
       this.output = output

   function start():
       try:
           gameWorld = new GameWorld(gameFileName)
           controller = new GameController(gameWorld, input, output)
           controller.play()
       catch Exception:
           throw IOException("Error starting game")

// GameWorld - Main model class
class GameWorld implements GameWorldLoader:
   properties:
       gameName: String
       version: String
       rooms: Map<String, Room>
       items: Map<String, Item>
       fixtures: Map<String, Fixture>
       puzzles: Map<String, Puzzle>
       monsters: Map<String, Monster>
       player: Player

   constructor(gameFileName):
       initialize empty maps for rooms, items, fixtures, puzzles, monsters
       loadGameData(gameFileName)
       initializePlayer()

   function loadGameData(gameFileName):
       parse JSON file
       load game metadata (name, version)
       load items
       load fixtures
       load puzzles
       load monsters
       load rooms
       connectRooms()

   function loadGameWorld(filename: String): GameWorld throws IOException:
       loadGameData(filename)
       return this

   function connectRooms():
       for each room in rooms:
           for each direction in (NORTH, SOUTH, EAST, WEST):
               targetRoomNumber = room.getExitRoomNumber(direction)
               if targetRoomNumber > 0:
                   targetRoom = rooms.get(targetRoomNumber)
                   room.setExit(direction, targetRoom)

   function applySolution(solution):
       currentRoom = player.getCurrentRoom()

       // Check if solution solves a puzzle
       if currentRoom has active puzzle:
           if puzzle.solve(solution):
               player.addScore(puzzle.getValue())
               unblockPaths(currentRoom)
               return true

       // Check if solution defeats a monster
       if currentRoom has active monster:
           if monster.getSolution() equals solution:
               monster.defeat()
               player.addScore(monster.getValue())
               unblockPaths(currentRoom)
               return true

       return false

   function unblockPaths(room):
       // After defeating a monster or solving a puzzle, unblock any paths that were blocked
       for each direction in (NORTH, SOUTH, EAST, WEST):
           exitNumber = room.getExitRoomNumber(direction)
           if parseInt(exitNumber) < 0:
               // Convert negative exit number to positive (unblocked) exit number
               room.setExitRoomNumber(direction, String.valueOf(Math.abs(parseInt(exitNumber))))

   function saveGame(filename):
       create JSON object with:
           player data (name, health, score, current room)
           inventory items
           room states (puzzle/monster active states, exits, items)
       write to file

   function loadGame(filename):
       read JSON from file
       restore player state (name, health, score)
       set player's current room
       restore player's inventory
       restore room states (puzzles, monsters, exits, items)

// Direction - Enum
enum Direction:
   NORTH, SOUTH, EAST, WEST

   function getOpposite():
       if this == NORTH: return SOUTH
       if this == SOUTH: return NORTH
       if this == EAST: return WEST
       if this == WEST: return EAST

// Room - Represents a location
class Room extends AbstractGameObject:
   properties:
       roomNumber: String
       exitRoomNumbers: Map<Direction, String>
       exits: Map<Direction, Room>
       items: List<Item>
       fixtures: List<Fixture>
       puzzle: Puzzle
       monster: Monster

   constructor(name, roomNumber, description, exitRoomNumbers):
       super(name, description)
       this.roomNumber = roomNumber
       this.exitRoomNumbers = exitRoomNumbers
       initialize empty lists/maps for items, fixtures, exits

   // Methods for exits
   function getExitRoomNumber(direction): return exitRoomNumbers.get(direction)
   function setExitRoomNumber(direction, roomNumber): exitRoomNumbers.put(direction, roomNumber)
   function setExit(direction, room): exits.put(direction, room)
   function getExit(direction): return exits.get(direction)

   // Methods for items
   function addItem(item): items.add(item)
   function removeItem(item): return items.remove(item)
   function getItem(itemName): return first item with matching name

   // Methods for fixtures
   function addFixture(fixture): fixtures.add(fixture)
   function getFixture(fixtureName): return first fixture with matching name

   // Methods for puzzle/monster
   function setPuzzle(puzzle): this.puzzle = puzzle
   function getPuzzle(): return puzzle
   function setMonster(monster): this.monster = monster
   function getMonster(): return monster

   // Getters for properties
   function getRoomNumber(): return roomNumber
   function getItems(): return copy of items list
   function getFixtures(): return copy of fixtures list
   function clearItems(): items.clear()

// Player - Represents the user's character
class Player extends AbstractGameObject:
   properties:
       health: Integer
       inventory: List<Item>
       currentRoom: Room
       score: Integer
       MAX_WEIGHT: Integer (constant = 13)
       attackPower: Integer
       criticalChance: Integer  // Percentage chance (0-100)

   constructor(name, startRoom):
       super(name, "The player character")
       health = 100
       inventory = new empty list
       currentRoom = startRoom
       score = 0
       attackPower = 10
       criticalChance = 15

   function getHealth(): return health
   function setHealth(health):
       this.health = health
       if this.health < 0: this.health = 0

   function takeDamage(amount):
       health -= amount
       if health < 0: health = 0

   function getHealthStatus():
       if health <= 0: return "ASLEEP"
       if health < 40: return "WOOZY"
       if health < 70: return "FATIGUED"
       return "AWAKE"

   function addToInventory(item):
       if getInventoryWeight() + item.getWeight() <= MAX_WEIGHT:
           inventory.add(item)
           return true
       return false

   function removeFromInventory(item): return inventory.remove(item)

   function getItemFromInventory(itemName):
       for each item in inventory:
           if item.getName() equals itemName (case insensitive):
               return item
       return null

   function getInventoryWeight():
       totalWeight = 0
       for each item in inventory:
           totalWeight += item.getWeight()
       return totalWeight

   function getInventory(): return copy of inventory list
   function setInventory(inventory): this.inventory = copy of inventory list

   function getCurrentRoom(): return currentRoom
   function setCurrentRoom(room): this.currentRoom = room

   function addScore(points): this.score += points
   function setScore(score): this.score = score
   function getScore(): return score

   function getRank():
       if score >= 1000: return "Adventure Master"
       if score >= 750: return "Expert Explorer"
       if score >= 500: return "Seasoned Adventurer"
       if score >= 250: return "Novice Explorer"
       return "Beginner"

   function attack(monster):
       // Check if attack is critical hit
       isCritical = random(1, 100) <= criticalChance

       // Calculate damage - critical hits do double damage
       damage = attackPower
       if isCritical:
           damage = attackPower * 2

       // Apply damage to monster
       result = monster.takeDamage(damage, isCritical)
       return result

// Item - Represents an object that can be picked up and used
class Item extends AbstractGameObject:
   properties:
       weight: Integer
       maxUses: Integer
       usesRemaining: Integer
       value: Integer
       whenUsed: String

   constructor(name, weight, maxUses, usesRemaining, value, whenUsed, description):
       super(name, description)
       this.weight = weight
       this.maxUses = maxUses
       this.usesRemaining = usesRemaining
       this.value = value
       this.whenUsed = whenUsed

   function use():
       if usesRemaining > 0:
           usesRemaining--
           return true
       return false

   // Getters and setters
   function getWhenUsed(): return whenUsed
   function getWeight(): return weight
   function getMaxUses(): return maxUses
   function getUsesRemaining(): return usesRemaining
   function setUsesRemaining(uses): this.usesRemaining = uses
   function getValue(): return value

// Fixture - Represents an immovable object in a room
class Fixture extends AbstractGameObject:
   properties:
       weight: Integer  // Always > 200 to be immovable

   constructor(name, weight, description):
       super(name, description)
       this.weight = weight

   function getWeight(): return weight

// Obstacle - Abstract class for things that can block paths
abstract class Obstacle extends AbstractGameObject implements Entity:
   properties:
       active: Boolean
       value: Integer
       effects: String
       target: String

   constructor(name, description, active, value, effects, target):
       super(name, description)
       this.active = active
       this.value = value
       this.effects = effects
       this.target = target

   function isActive(): return active
   function setActive(active): this.active = active
   function getValue(): return value
   function getEffects(): return effects
   function getTarget(): return target

   // Abstract method to be implemented by subclasses
   abstract function resolve(solution: String): Boolean

// Puzzle - Represents a challenge that blocks a path
class Puzzle extends Obstacle:
   properties:
       affectsTarget: Boolean
       affectsPlayer: Boolean
       solution: String

   constructor(name, active, affectsTarget, affectsPlayer, solution, value, description, effects, target):
       super(name, description, active, value, effects, target)
       this.affectsTarget = affectsTarget
       this.affectsPlayer = affectsPlayer
       this.solution = solution

   function affectsTarget(): return affectsTarget
   function affectsPlayer(): return affectsPlayer
   function getSolution(): return solution

   // Implement resolve method from Obstacle
   override function resolve(solution: String): Boolean:
       return solve(solution)

   function solve(solution):
       // Check for text answer solutions (with quotes)
       if this.solution starts with "'" and ends with "'":
           answerWithoutQuotes = this.solution without quotes
           if active and answerWithoutQuotes equals solution (case insensitive):
               active = false
               return true
       // Normal item solution
       else if active and this.solution equals solution (case insensitive):
           active = false
           return true
       return false

// Monster - Represents an enemy that can attack